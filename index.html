<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=, initial-scale=1.0">
  <title>オセロゲーム</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="https://code.jquery.com/jquery-3.6.0.js" integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk=" crossorigin="anonymous"></script>
</head>
<body>
  <div style="text-align: center;">
    <table class="board">
      <tbody class="body">
      </tbody>
    </table>

    <button id="pass" style="display: inline-block; margin-top:20px; width: 100px;">パス</button>

    <p>※ 黒が先行</p>

    <div id="winner">
    </div>
    <p style="margin-top: 30px;">リセットするにはブラウザを更新してください</p>
  </div>

  <script>
    
    $(document).ready(function () {
      //////////////
      // 必要データ
      //////////////
      // 状態
      const black = 1;
      const white = 2;
      const none = 0;
      // 0が未入力、1が黒、2が白
      let current_state = {};
      // ゲーム終了判定
      let is_finish = false;




      
      /////////////
      // 要素作成
      /////////////
      const tbody = $(".body");
      // 初期データ作成
      const make_current_state = (current_state) => {
        for(let i = 0; i < 8; i++) {
          if (i == 3) {
            current_state[i] = [none, none, none, black, white, none, none, none];
          } else if (i == 4) {
            current_state[i] = [none, none, none, white, black, none, none, none];
          } else {
            current_state[i] = [none, none, none, none, none, none, none, none];
          }
        }

        return current_state;
      }
      // 初期データ
      current_state = make_current_state(current_state);
      
      // 要素作成
      Object.keys(current_state).forEach((key) => {
        let tr = $("<tr></tr>").appendTo(tbody);

        current_state[key].forEach((val, k) => {
          let id = key + '-' + k;
          let td = $('<td></td>').appendTo(tr);
          $('<canvas  id="'+id+'" class="canvas" width="70px" height="70px"></canvas>').appendTo(td);


          if (val == black) {
            let ctx = $('#'+id).get(0).getContext("2d");
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(35, 35, 20, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();
          } else if (val == white) {
            let ctx = $('#'+id).get(0).getContext("2d");
            ctx.strokeStyle = "black";
            ctx.beginPath();
            ctx.arc(35, 35, 20, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.stroke();
          }
        });
      });






      ////////////////////
      // クリックイベント
      ////////////////////
      // 順番フラグ
      let turn;
      let count = 1;
      // クリック可能かのフラグ
      let can_click = false;
      $(".canvas").on("click", (e) => {
        // 終了したら押せない
        if (is_finish) {
          return;
        }

        // クリックされた要素を取得
        let id = e.target.id;
        let [vertical, beside] = id.split( '-' );
        vertical = Number(vertical);
        beside = Number(beside);
        // 既に入力済みのマス目は押せない
        if (current_state[vertical][beside] != 0) {
          return;
        }

        // 順番を取得
        turn = count % 2 == 1 ? black : white;

        // 下方向の判定
        let under_data = vertical_under_judge(current_state, vertical, beside, turn);
        let vertical_under_enemy_count = under_data[0];
        can_click = under_data[1];
        // 上方向の判定
        let upper_data = vertical_upper_judge(current_state, vertical, beside, turn);
        let vertical_upper_enemy_count = upper_data[0];
        can_click = can_click == false ? upper_data[1] : can_click;
        // 右方向の判定
        let right_data = beside_right_judge(current_state, vertical, beside, turn);
        let beside_right_enemy_count = right_data[0];
        can_click = can_click == false ? right_data[1] : can_click;
        // 左方向の判定
        let left_data = beside_left_judge(current_state, vertical, beside, turn);
        let beside_left_enemy_count = left_data[0];
        can_click = can_click == false ? left_data[1] : can_click;
        // 斜め左下方向の判定
        let left_under_data = left_under_judge(current_state, vertical, beside, turn);
        let left_under_enemy_count = left_under_data[0];
        can_click = can_click == false ? left_under_data[1] : can_click;
        // 斜め右下方向の判定
        let right_under_data = right_under_judge(current_state, vertical, beside, turn);
        let right_under_enemy_count = right_under_data[0];
        can_click = can_click == false ? right_under_data[1] : can_click;
        // 斜め左上方向の判定
        let left_upper_data = left_upper_judge(current_state, vertical, beside, turn);
        let left_upper_enemy_count = left_upper_data[0];
        can_click = can_click == false ? left_upper_data[1] : can_click;
        // 斜め右上方向の判定
        let right_upper_data = right_upper_judge(current_state, vertical, beside, turn);
        let right_upper_enemy_count = right_upper_data[0];
        can_click = can_click == false ? right_upper_data[1] : can_click;

        

        // 変換
        if (can_click) {
          let ctx = e.target.getContext("2d");
          if (turn == black) {
            ctx.fillStyle = "black"
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;


          // 下方向
          current_state = change_under(current_state, vertical, beside, vertical_under_enemy_count, turn);

          // 上方向
          current_state = change_upper(current_state, vertical, beside, vertical_upper_enemy_count, turn);

          // 左方向
          current_state = change_left(current_state, vertical, beside, beside_left_enemy_count, turn);

          // 右方向
          current_state = change_right(current_state, vertical, beside, beside_right_enemy_count, turn);

          // 右上方向
          current_state = change_right_upper(current_state, vertical, beside, right_upper_enemy_count, turn);

          // 左上方向
          current_state = change_left_upper(current_state, vertical, beside, left_upper_enemy_count, turn);

          // 右下方向
          current_state = change_right_under(current_state, vertical, beside, right_under_enemy_count, turn);

          // 左下方向
          current_state = change_left_under(current_state, vertical, beside, left_under_enemy_count, turn);


          count++;

          // 終了判定
          is_finish = check_finish(current_state);

          if (is_finish) {
            let winner = which_winner(current_state);
            let div = $("#winner");
            $('<p style="color:red;">'+winner+'</p>').appendTo(div);
          }
        }

        // console.log(can_click);
      });


      $("#pass").on("click", () => {
        count++;
      });



      // 下方向の判定
      const vertical_under_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = vertical; i < 8; i++) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside] == none) {
            return [0, false];
          }

          if (current_state[i][beside] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          count++;
        }

        return [0, false];
      }


      // 上方向の判定
      const vertical_upper_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = vertical; i >= 0; i--) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside] == none) {
            return [0, false];
          }

          if (current_state[i][beside] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          count++;
        }

        return [0, false];
      }


      // 右方向の判定
      const beside_right_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = beside; i < 8; i++) {
          if (i == beside) {
            continue;
          }

          if (current_state[vertical][i] == none) {
            return [0, false];
          }

          if (current_state[vertical][i] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          count++;
        }

        return [0, false];
      }
      

      // 左方向の判定
      const beside_left_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = beside; i >= 0; i--) {
          if (i == beside) {
            continue;
          }

          if (current_state[vertical][i] == none) {
            return [0, false]
          }

          if (current_state[vertical][i] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          } 

          count++;
        }

        return [0, false];
      }


      // 右斜め上方向の判定
      const right_upper_judge = (current_state, vertical, beside, turn) => {  
        let count = 0;      
        for (let i = vertical; i >= 0; i--) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside+1] == none) {
            return [0, false];
          }

          if (current_state[i][beside+1] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          beside++;
          count++;
        }

        return [0, false];
      }


      // 左斜め上方向の判定
      const left_upper_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = vertical; i >= 0; i--) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside-1] == none) {
            return [0, false];
          }

          if (current_state[i][beside-1] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          beside--;
          count++;
        }

        return [0, false];
      }


      // 右斜め下方向の判定
      const right_under_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = vertical; i < 8; i++) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside+1] == none) {
            return [0, false];
          }

          if (current_state[i][beside+1] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          beside++;
          count++;
        }

        return [0, false];
      }


      // 左斜め下方向の判定
      const left_under_judge = (current_state, vertical, beside, turn) => {
        let count = 0;
        for (let i = vertical; i < 8; i++) {
          if (i == vertical) {
            continue;
          }

          if (current_state[i][beside-1] == none) {
            return [0, false];
          }

          if (current_state[i][beside-1] == turn) {
            let can_click = count == 0 ? false : true;
            return [count, can_click];
          }

          beside--;
          count++;
        }

        return [0, false];
      }





      // 下方向変換
      const change_under = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical++;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 上方向変換
      const change_upper = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical--;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 左方向変換
      const change_left = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          beside--;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 右方向変換
      const change_right = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          beside++;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 右上方向変換
      const change_right_upper = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical--;
          beside++;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 左上方向変換
      const change_left_upper = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical--;
          beside--;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 右下方向変換
      const change_right_under = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical++;
          beside++;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }


      // 左下方向変換
      const change_left_under = (current_state, vertical, beside, count, turn) => {
        for (let i = 1; i <= count; i++ ) {
          vertical ++;
          beside --;
          let ctx = $("#"+vertical+"-"+beside).get(0).getContext("2d");
          ctx.clearRect(0, 0, 200, 200);
          if (turn == black) {
            ctx.fillStyle = "black";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.beginPath();
          ctx.arc(35, 35, 20, 0, 2 * Math.PI);
          ctx.closePath();
          turn == black ? ctx.fill() : ctx.stroke();
          current_state[vertical][beside] = turn == black ? black : white;
        }

        return current_state;
      }





      // 終了判定
      const check_finish = (current_state) => {
        let is_finish = true;
        Object.keys(current_state).forEach((key) => {
          current_state[key].forEach((val) => {
            if (val == 0) {
              is_finish = false;
            }
          })
        });

        return is_finish;
      }


      // 勝敗判定
      const which_winner = (current_state) => {
        let black_count = 0;
        let white_count = 0;

        Object.keys(current_state).forEach((key) => {
          current_state[key].forEach((val) => {
            if (val == 1) {
              black_count++;
            } else if (val == 2) {
              white_count++;
            }
          })
        });

        if (black_count > white_count) {
          return '黒の勝ち';
        } else if (black_count < white_count) {
          return '白の勝ち';
        } else if (black_count == white_count) {
          return '引き分け;'
        }
        
      }


    });




  </script>
</body>
</html>